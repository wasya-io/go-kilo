# イベント駆動型アーキテクチャ移行計画

## 概要
現在のエディタをイベント駆動型アーキテクチャに移行し、より柔軟で拡張性の高い構造に改善する計画です。
この移行は段階的に行い、既存の機能を維持しながら新しいアーキテクチャを導入していきます。

## 移行の目的
- コンポーネント間の疎結合化
- 機能拡張の容易性向上
- テスト容易性の向上
- プラグイン機構の導入準備

## アーキテクチャの設計

### 1. イベントシステムの基盤
#### イベントタイプ
- 入力イベント（キー入力、マウス入力）
- バッファイベント（テキスト変更、カーソル移動）
- UI更新イベント（表示更新、スクロール）
- ファイル操作イベント（読み込み、保存）

#### コアコンポーネント
1. EventManager
   - イベントの発行と購読を管理
   - イベントキューの制御
   - イベントハンドラの登録/解除

2. InputEventEmitter
   - キー入力をイベントに変換
   - 入力イベントの発行

3. BufferEventHandler
   - テキスト操作イベントの処理
   - バッファ状態の管理

4. UIEventHandler
   - 表示更新イベントの処理
   - スクロール制御

5. FileEventHandler
   - ファイル操作イベントの処理
   - ストレージとの連携

### 2. 実装フェーズ
#### フェーズ1: イベントシステムの基盤実装
1. イベントマネージャーの実装
   - イベント型の定義
   - イベントバスの実装
   - 基本的なイベントディスパッチ機能

2. 既存コードの分析
   - 現在のコマンドパターンとの統合ポイントの特定
   - イベント化が必要な操作の洗い出し

#### フェーズ2: コンポーネントの段階的移行
1. InputHandlerの移行
   - キー入力のイベント化
   - コマンドパターンとの橋渡し実装

2. バッファ操作の移行
   - テキスト操作イベントの実装
   - バッファ状態変更の通知機構

3. UI更新の移行
   - 表示更新イベントの実装
   - スクロールイベントの統合

#### フェーズ3: プラグイン機構の準備
1. イベントリスナーインターフェースの設計
2. プラグイン登録機構の実装
3. 基本的なプラグインAPIの定義

### 3. マイグレーション戦略
1. 既存機能の維持
   - 段階的な移行による機能の安定性確保
   - 各フェーズでのテスト coverage の維持

2. 新機能の実装方針
   - 新機能は新アーキテクチャベースで実装
   - 既存機能は段階的に移行

3. 下位互換性の維持
   - 既存のAPIとの互換レイヤーの提供
   - 非推奨化と移行期間の設定

## 技術的な考慮事項
- Goのチャネルとgoroutineの効果的な活用
- イベントの優先順位付けと順序保証
- メモリ効率とパフォーマンスの最適化
- エラーハンドリングとリカバリー機構
- デバッグとモニタリングの仕組み

## UI更新の実装計画

### 1. イベント構造の拡張
#### 追加すべきUIイベントタイプ
- 部分更新イベント（行単位の更新）
- カーソル位置更新イベント
- コンポーネント固有の更新イベント
  - エディタ領域更新
  - ステータスバー更新
  - メッセージバー更新
- スクロール関連イベント
  - スムーズスクロール
  - 部分スクロール

#### イベントの最適化機構
- 更新の優先順位付け
- イベントのバッチ処理
  - 複数更新の集約
  - 不要な更新の排除
- 更新タイミングの制御

### 2. UIコンポーネントの分離
#### コンポーネント構造
- エディタ領域
  - テキスト表示
  - カーソル制御
  - 選択範囲表示
- ステータスバー
  - ファイル情報
  - 編集状態
- メッセージバー
  - 通知表示
  - エラー表示

#### コンポーネント間の連携
- イベントベースの状態同期
- 独立した更新サイクル
- レイアウト管理の改善

### 3. パフォーマンス最適化
#### 更新制御メカニズム
- 描画キューイング
- バッファリング
- 差分更新

#### スクロール制御の改善
- スクロール状態の抽象化
- スムーズスクロールの実装
- パフォーマンスを考慮したビューポート管理

### 4. 実装優先順位
1. 基本イベント構造の拡張
   - 細かい粒度のイベントタイプ追加
   - バッチ処理の基盤実装

2. コンポーネントの分離
   - UI要素の独立したコンポーネント化
   - イベントベースの更新制御実装

3. 最適化機構の導入
   - 更新制御の実装
   - パフォーマンス改善

4. 高度な機能の実装
   - スムーズスクロール
   - アニメーション対応

## タイムライン
1. フェーズ1: イベントシステム基盤（2-3週間）
2. フェーズ2: コンポーネント移行（3-4週間）
3. フェーズ3: プラグイン機構（2-3週間）

## 成功指標
- コードの凝集度と結合度の改善
- テストカバレッジの維持/向上
- 新機能追加時の開発効率
- バグ修正の容易性

## 実装状況と進捗

### フェーズ1: イベントシステム基盤（完了）
1. イベントマネージャーの実装
   - ✅ イベント型の定義完了
   - ✅ イベントバスの実装完了
   - ✅ イベントディスパッチ機能実装完了
   - ✅ エラー処理とリカバリー機構の実装完了
   - ✅ バッチ処理とキューイング機構の実装完了

2. イベントモニタリング
   - ✅ エラーログとモニタリング機能実装完了
   - ✅ スナップショットとリカバリー機能実装完了

### フェーズ2: コンポーネント移行（進行中）
1. InputHandlerの移行
   - ✅ 基本的なキー入力イベント実装完了
   - ✅ InputEventEmitterの実装完了
   - 🔄 マウス入力対応の拡張中
   - 🔄 IME入力のイベント化対応中

2. バッファ操作の移行
   - ✅ テキスト操作イベントの実装完了
   - ✅ バッファ状態変更の通知機構実装完了
   - 🔄 構造的変更のイベント最適化中

3. UI更新の移行
   - ✅ 基本的なUI更新イベント実装完了
   - ✅ コンポーネント別更新機能実装完了
   - 🔄 バッチ更新とパフォーマンス最適化中
   - ❌ スムーズスクロール未実装

### フェーズ3: プラグイン機構（未着手）
1. プラグインインターフェース設計
2. プラグイン登録機構実装
3. プラグインAPIの定義と実装

## 今後の優先課題

### 1. パフォーマンス最適化（高優先）
- イベントバッチ処理の効率化
- 更新制御メカニズムの改善
- メモリ使用量の最適化

### 2. 機能拡張（中優先）
- スムーズスクロール実装
- マウス操作の完全対応
- IME入力の完全対応

### 3. プラグイン基盤（低優先）
- プラグインインターフェースの設計
- 基本的なプラグインAPIの実装

## タイムライン更新
1. ✅ フェーズ1: イベントシステム基盤（完了）
2. 🔄 フェーズ2: コンポーネント移行（2-3週間）
3. ❌ フェーズ3: プラグイン機構（3-4週間）

## コマンドベースからイベントベースへの段階的移行計画

### 1. カーソル操作の移行（第一段階）
#### 理由
- 副作用が比較的少なく、状態変更が明確
- UI更新との連携が必要で、イベントベースの利点が活かせる
- 他の機能への影響が限定的

#### 移行手順
1. CursorEvent型の追加実装
   - Position、Direction情報を含む
   - イベントの優先度設定

2. カーソル移動コマンドの移行
   - 既存コマンドをラップしてイベント発行
   - 段階的な置き換え
   - UIのカーソル更新処理をイベントハンドラとして実装

3. スクロール連携
   - スクロール処理をイベントチェーンとして実装
   - カーソル移動に伴う自動スクロールの統合

#### カーソル操作のイベントフロー詳細
1. 現状の処理フロー
```
MoveCursorCommand.Execute()
└→ Editor.MoveCursor()
   └→ UI.MoveCursor()
      ├→ calculateNewCursorPosition() // 位置計算
      └→ SetCursor()                  // 位置更新
         └→ QueueUpdate(AreaCursor)   // 画面更新
```

2. イベントベース化後の処理フロー
```
MoveCursorCommand.Execute()
└→ Editor.MoveCursor()
   └→ eventManager.Publish(CursorEvent)
      └→ UI.handleCursorEvent()           // イベントハンドラ
         ├→ calculateNewCursorPosition()   // 位置計算（既存処理を再利用）
         └→ updateCursorPosition()         // 位置更新
            ├→ publishCursorUpdateEvent()  // 位置更新イベント発行
            └→ QueueUpdate(AreaCursor)     // 画面更新要求
```

3. カーソル関連イベントの種類
- CursorMoveEvent: カーソル移動要求
  - Direction: 移動方向（Up/Down/Left/Right）
  - Distance: 移動量
  - IsRelative: 相対移動か絶対移動か

- CursorUpdateEvent: カーソル位置更新通知
  - Position: 新しい位置（X, Y）
  - Source: 更新元（Move/Set/Scroll等）

4. イベントハンドラの責務
- UI.handleCursorEvent()
  - カーソル移動要求の処理
  - バッファ境界のチェック
  - 新しい位置の計算
  - マルチバイト文字の考慮

- UI.handleCursorUpdateEvent()
  - カーソル位置の更新
  - スクロール位置の調整
  - 画面更新の要求
  - 関連コンポーネントへの通知

5. 移行手順の詳細
- フェーズ1: イベント発行の導入
  - CursorEvent型の実装
  - 既存のMoveCursor/SetCursor内でのイベント発行
  - 既存の処理フローの維持

- フェーズ2: イベントハンドラの実装
  - handleCursorEvent/handleCursorUpdateEventの実装
  - 既存の位置計算ロジックの移行
  - テストケースの追加

- フェーズ3: コマンドの移行
  - MoveCursorCommandの更新
  - 直接的なUI操作の削除
  - イベントベースの処理への完全移行

### 2. テキスト選択操作の移行（第二段階）
#### 理由
- カーソル操作の拡張として自然な流れ
- 選択範囲のUI更新にイベントが有効

#### 移行手順
1. SelectionEvent型の実装
   - 選択範囲情報の定義
   - 選択状態の変更通知

2. 選択操作の移行
   - 選択コマンドのイベント化
   - 選択範囲のUI更新をイベントハンドラで実装
   - カーソルイベントとの連携

### 3. 単一文字編集操作の移行（第三段階）
#### 理由
- 基本的な編集操作で影響範囲が予測可能
- Undoスタックとの連携が必要だがスコープは限定的

#### 移行手順
1. CharacterEvent型の実装
   - 文字の挿入/削除イベント
   - 影響範囲の特定機能

2. 文字操作の移行
   - 文字操作コマンドのイベント化
   - バッファ更新処理をイベントハンドラで実装
   - Undo/Redoシステムとの連携実装

### 4. 行操作の移行（第四段階）
#### 理由
- 構造的な変更を伴うが影響範囲は予測可能
- バッファとUIの同期が重要

#### 移行手順
1. LineEvent型の実装
   - 改行、行削除等のイベント定義
   - 行範囲の変更通知

2. 行操作の移行
   - 行操作コマンドのイベント化
   - バッファ更新とUI更新の連携をイベントで実装
   - 構造的変更の最適化

### 5. ファイル操作の移行（第五段階）
#### 理由
- 大規模な状態変更を伴う
- エラーハンドリングが重要

#### 移行手順
1. FileEvent型の拡張
   - 既存実装の強化
   - エラー状態の詳細化

2. ファイル操作の移行
   - ファイル操作コマンドのイベント化
   - エラーハンドリングとリカバリーの実装
   - 状態同期の最適化

### 移行戦略のポイント

#### 1. 段階的なハイブリッド運用
- コマンドパターンとイベントパターンの共存
- コマンドからイベントを発行する中間層の導入
- 徐々にコマンドをイベントに置き換え

#### 2. テスト駆動での移行
- 各段階での機能テストの作成
- イベントの発行と処理の検証
- エッジケースの網羅

#### 3. パフォーマンスモニタリング
- 各段階での性能測定
- イベントの最適化（バッチ処理、キューイング）
- メモリ使用量の監視

#### 4. フォールバック機構
- 問題発生時のコマンドベースへの一時的な切り戻し
- 段階的なロールアウトとロールバック計画

## イベントキューイングと処理の未実装ポイント

### 1. イベントの優先順位制御
#### 現状の課題
- イベントタイプ間の優先順位付けが不完全
- バッチ処理時の実行順序制御が不十分
- イベント間の依存関係が考慮されていない

#### 実装が必要な機能
1. イベント優先度の体系化
   - イベントタイプごとの基本優先度設定
   - コンテキストに応じた動的優先度調整
   - 優先度継承メカニズム

2. イベント依存関係の管理
   - イベント間の依存グラフ構築
   - 循環依存の検出と解決
   - 依存関係に基づく実行順序の最適化

### 2. バッチ処理の最適化
#### 現状の課題
- バッチ処理時のイベント統合ロジックが不足
- メモリ効率が考慮されていない
- バッチサイズの動的調整機能がない

#### 実装が必要な機能
1. イベント統合メカニズム
   - 同種イベントの集約ルール定義
   - 競合解決戦略の実装
   - 統合結果の整合性検証

2. メモリ管理の最適化
   - イベントプールの導入
   - メモリ使用量の監視と制御
   - ガベージコレクションの最適化

### 3. エラー処理とリカバリー
#### 現状の課題
- バッチ処理中のエラー伝播が不完全
- 部分的な失敗からの復帰機能が不足
- トランザクション的な処理の保証がない

#### 実装が必要な機能
1. エラー伝播の改善
   - エラーコンテキストの強化
   - エラー影響範囲の特定
   - 適切なエラーログの実装

2. リカバリー機構の強化
   - チェックポイントの自動設定
   - ロールバック機能の実装
   - 段階的なリカバリー戦略

### 4. パフォーマンスモニタリング
#### 現状の課題
- イベント処理のパフォーマンス計測が不足
- ボトルネック検出機能がない
- リソース使用状況の可視化が不十分

#### 実装が必要な機能
1. メトリクス収集
   - イベント処理時間の計測
   - キューの長さモニタリング
   - リソース使用量の追跡

2. 分析ツール
   - パフォーマンスプロファイリング
   - ボトルネック検出アルゴリズム
   - 自動最適化提案機能

### 5. デバッグ機能
#### 現状の課題
- イベントフローの可視化が不足
- デバッグ情報の収集が不十分
- テスト用の制御機能が限定的

#### 実装が必要な機能
1. イベントトレーシング
   - イベントフローの記録
   - イベント間の関係性の可視化
   - タイムライン表示機能

2. デバッグツール
   - イベントインスペクタ
   - 状態検査機能
   - テスト用のモック/スタブ機能

## イベントキューイングの課題分析

### 1. キューイング構造の分散
#### 現状の実装
- EventManager: イベントの一時保管用バッチキュー
- UI: UI更新用のペンディングキュー
- Buffer: 未実装（直接更新）

#### 影響範囲と課題
1. 整合性の問題
   - 複数のキューで状態が分散
   - キュー間の同期が不完全
   - 順序保証が不十分

2. パフォーマンスへの影響
   - キュー間のコピーオーバーヘッド
   - メモリの非効率な使用
   - GCの頻発

### 2. イベントの優先度制御の不整合
#### 現状の実装状況
1. UI更新の優先度
   - High/Medium/Low の3段階
   - 更新エリアごとに固定的
   - オーバーライド機能が限定的

2. イベント処理の優先度
   - バッファイベントが常に最優先
   - その他のイベントは同一優先度
   - 動的な優先度変更不可

#### リスク分析
1. デッドロックの可能性
   - 優先度逆転問題の潜在リスク
   - イベント間の循環待ち

2. パフォーマンス低下
   - 不要な更新の発生
   - 優先度の低いイベントの遅延

### 3. バッチ処理の制御機構
#### 現状の実装の制限
1. バッチの開始/終了制御
   - 明示的な制御が必要
   - ネストされたバッチ処理の未対応
   - エラー発生時の部分的ロールバック不可

2. イベントの集約
   - 同一エリアの更新のみ集約
   - イベント間の関連性を考慮せず
   - 集約ルールのカスタマイズ不可

#### 潜在的な問題
1. メモリリーク
   - バッチモード終了忘れ
   - 未処理イベントの蓄積

2. 非効率な更新
   - 過剰な画面更新
   - 不要なイベント発行

### 4. エラー処理の不完全性
#### 現状の実装の弱点
1. エラー伝播
   - イベントチェーン中の一部のみ
   - コンテキスト情報の欠落
   - 非同期エラーの捕捉不足

2. リカバリー機構
   - 部分的なロールバックのみ
   - 状態の一貫性保証が不完全
   - 再試行戦略の未実装

#### 影響度
1. 安定性への影響
   - 予期せぬ状態の発生
   - データの整合性損失
   - ユーザー体験の低下

2. 保守性への影響
   - エラー原因の特定困難
   - デバッグの複雑化
   - 機能追加時のリスク増大

### 5. スケーラビリティの制限
#### 現状の制約
1. 同期処理の制限
   - イベント処理が基本的に同期的
   - goroutineの限定的な使用
   - 非同期処理のサポート不足

2. キャパシティ制限
   - キューサイズの固定
   - メモリ使用量の制御なし
   - スロットリング機能の欠如

#### 将来的な課題
1. 機能拡張時の問題
   - プラグイン対応の困難さ
   - 新規イベントタイプの追加コスト
   - パフォーマンスのボトルネック

2. 運用面での課題
   - モニタリングの困難さ
   - トラブルシューティングの複雑化
   - パフォーマンスチューニングの制限

### 6. リアルタイム性の保証
#### 現状の制限事項
1. レイテンシ制御
   - イベント処理の遅延が予測不可
   - 優先度による制御が不十分
   - 処理時間の保証なし

2. 応答性への影響
   - UI更新の遅延発生
   - キー入力の遅延可能性
   - スクロールの不自然さ

#### 改善が必要な点
1. パフォーマンス指標
   - レイテンシの測定機能
   - ボトルネックの可視化
   - リアルタイムモニタリング

2. 制御機構
   - イベントのスロットリング
   - バッファリング戦略
   - プライオリティスケジューリング

## イベントキューイングの依存関係分析

### 1. キューイング層の階層構造
#### 現状の依存関係
```
EventManager
└→ UpdateQueue（イベントの一時保管）
   └→ UI.QueueUpdate（画面更新要求）
      └→ pendingUpdates（更新の保留）
         └→ Buffer（直接更新）
```

#### 問題点
1. 直列的な依存
   - 上位層のエラーが下位層に伝播
   - 下位層のブロックが上位層に影響
   - リカバリーが困難

2. 状態管理の分散
   - 各層で独立したバッチモード管理
   - 状態の整合性保証が複雑
   - デバッグが困難

### 2. イベント処理の順序依存
#### クリティカルパス
1. バッファ更新の依存チェーン
```
BufferEvent
└→ テキスト更新
   └→ カーソル位置更新
      └→ スクロール位置更新
         └→ 画面更新
```

2. UI更新の依存チェーン
```
UIEvent
└→ レイアウト更新
   └→ 表示内容更新
      └→ カーソル位置更新
         └→ スクロール同期
```

#### リスク要因
1. デッドロックの可能性
   - カーソル移動 → スクロール → レイアウト → カーソル
   - バッファ更新 → UI更新 → バッファ検証 → バッファ更新

2. 循環参照
   - EventManager ↔ UI
   - Buffer ↔ Cursor
   - Scroll ↔ Layout

### 3. イベントの優先度競合
#### 競合パターン
1. 即時更新と遅延更新
   - キー入力（即時）vs バッチ更新（遅延）
   - スクロール（即時）vs レイアウト更新（遅延）
   - カーソル移動（即時）vs テキスト更新（遅延）

2. リソース競合
   - バッファアクセス
   - 画面更新リソース
   - メモリ使用量

#### 解決が必要な課題
1. 優先度の整理
   - イベントタイプ間の優先関係の明確化
   - コンテキストに応じた動的優先度
   - 優先度の継承ルール

2. リソース管理
   - 共有リソースのロック戦略
   - デッドロック防止機構
   - リソース使用量の制御

### 4. エラー伝播の経路
#### エラーの流れ
1. 上位から下位への伝播
```
EventManager エラー
└→ UpdateQueue エラー
   └→ UI更新エラー
      └→ バッファ操作エラー
```

2. 下位から上位への伝播
```
バッファ操作エラー
└→ UI更新エラー
   └→ イベント処理エラー
      └→ コマンド実行エラー
```

#### エラーハンドリングの課題
1. エラーのスコープ
   - 局所的なリカバリー
   - 関連コンポーネントの整合性
   - システム全体の安定性

2. エラーの分類
   - 致命的エラー
   - 復旧可能エラー
   - 警告レベルのエラー

### 5. パフォーマンスのボトルネック
#### 処理時間の集中
1. イベントディスパッチ
   - イベントの配送オーバーヘッド
   - サブスクライバー呼び出しコスト
   - イベントキューの処理時間

2. バッチ処理
   - バッチのサイズ管理
   - メモリ消費のスパイク
   - GCへの影響

#### 最適化ポイント
1. キューイング戦略
   - バッチサイズの動的調整
   - イベントの結合と分割
   - 優先度に基づく処理順序

2. メモリ管理
   - オブジェクトプール
   - メモリ割り当ての最適化
   - GCフレンドリーな設計

## イベントキューイング実装の優先順位

### 第1フェーズ: 基盤の強化
#### 1. キューイング層の再構築
1. イベントキューの一元管理
   - UpdateQueueの責務の明確化
   - キュー操作のインターフェース整理
   - スレッドセーフな実装の確認

2. バッチ処理の制御機構
   - ネストされたバッチの対応
   - トランザクション的な処理の導入
   - ロールバック機能の実装

#### 2. 優先度制御の確立
1. 優先度体系の整備
   - イベントタイプごとの基本優先度
   - コンテキスト依存の優先度
   - 優先度継承のルール

2. イベント依存関係の管理
   - 依存グラフの構築
   - 循環参照の検出機構
   - デッドロック防止の仕組み

### 第2フェーズ: エラー処理の強化
#### 1. エラー伝播の整備
1. エラーコンテキストの強化
   - エラー情報の詳細化
   - 発生位置の特定
   - 影響範囲の把握

2. リカバリー機構の実装
   - 部分的なロールバック
   - 状態の一貫性保証
   - 自動リカバリーの仕組み

#### 2. エラーハンドリングの改善
1. エラーの分類と対応
   - 致命的エラーの特定
   - 復旧可能エラーの処理
   - 警告レベルの扱い

2. エラーログの強化
   - コンテキスト情報の記録
   - エラーチェーンの追跡
   - デバッグ情報の収集

### 第3フェーズ: パフォーマンスの最適化
#### 1. メモリ管理の改善
1. メモリ効率の向上
   - オブジェクトプールの導入
   - メモリ割り当ての最適化
   - GC負荷の軽減

2. バッチ処理の最適化
   - バッチサイズの動的調整
   - メモリ使用量の制御
   - イベントの統合ルール

#### 2. 処理効率の改善
1. イベントディスパッチの最適化
   - ディスパッチャーの効率化
   - サブスクライバー呼び出しの改善
   - キュー処理の高速化

2. UI更新の効率化
   - 更新範囲の最適化
   - 不要な更新の排除
   - レンダリングの効率化

### 第4フェーズ: モニタリングと分析
#### 1. パフォーマンス計測
1. メトリクス収集の整備
   - 処理時間の計測
   - メモリ使用量の追跡
   - キューの状態監視

2. ボトルネック分析
   - ホットスポットの特定
   - リソース競合の検出
   - パフォーマンス低下の予測

#### 2. デバッグ機能の強化
1. トレーシング機能
   - イベントフローの記録
   - 依存関係の可視化
   - タイムライン表示

2. 分析ツール
   - イベントインスペクタ
   - 状態検査機能
   - プロファイリング機能

### 実装の注意点
1. 段階的な移行
   - 既存機能の維持
   - バックワードコンパティビリティ
   - フォールバック機能の確保

2. テストの重要性
   - ユニットテストの拡充
   - 統合テストの強化
   - パフォーマンステスト

3. ドキュメンテーション
   - 設計意図の記録
   - APIの使用方法
   - トラブルシューティングガイド

4. レビューのポイント
   - コードの品質
   - パフォーマンスへの影響
   - エラー処理の妥当性

## イベントキューイング実装の技術的な注意点

### 1. 並行処理制御
#### 現状の課題
1. ミューテックスの使用範囲
   ```go
   // 現状のパターン
   func (q *UpdateQueue) Add(event Event) {
       q.mu.Lock()
       defer q.mu.Unlock()
       q.queue = append(q.queue, event)
   }
   ```
   - ロックの粒度が細かすぎる
   - デッドロックの潜在リスク
   - パフォーマンスへの影響

2. イベント処理の同期
   ```go
   // 要注意なパターン
   func (em *EventManager) ProcessUpdates() {
       em.updateQueue.Flush(func(event Event) {
           em.publishEvent(event)  // 同期的な処理
       })
   }
   ```
   - 処理のブロッキング
   - リソースの専有
   - レスポンス性の低下

#### 改善方針
1. ロック戦略の見直し
   - Read/Writeロックの使い分け
   - ロックの保持時間の最小化
   - ロックフリーアルゴリズムの検討

2. 非同期処理の活用
   - goroutineの適切な利用
   - チャネルベースの通信
   - コンテキストによる制御

### 2. メモリ管理
#### 現状の課題
1. メモリアロケーション
   ```go
   // 非効率なパターン
   queue = make([]Event, 0)  // 都度アロケーション
   ```
   - 頻繁なアロケーション
   - GC負荷の増大
   - メモリフラグメンテーション

2. バッファサイズ
   ```go
   // 制御が不十分なパターン
   em.batchEvents = append(em.batchEvents, event)
   ```
   - 動的な拡張に依存
   - メモリ使用量の予測困難
   - スパイクの発生

#### 改善方針
1. メモリプール導入
   ```go
   // 推奨パターン
   type EventPool struct {
       pool sync.Pool
       capacity int
   }
   ```
   - オブジェクトの再利用
   - アロケーションの削減
   - GC負荷の軽減

2. サイズ管理の改善
   - 適切な初期サイズ
   - 上限値の設定
   - 動的な調整メカニズム

### 3. エラー処理
#### 現状の課題
1. エラー情報の不足
   ```go
   // 不十分なパターン
   if err != nil {
       return err
   }
   ```
   - コンテキスト情報の欠落
   - エラーチェーンの断絶
   - デバッグ困難

2. リカバリー処理
   ```go
   // リスクの高いパターン
   defer em.ClearBatch()  // 単純なクリア
   ```
   - 状態の一貫性が不保証
   - 部分的な失敗への対応不足
   - サイドエフェクトの考慮不足

#### 改善方針
1. エラーハンドリングの強化
   ```go
   // 推奨パターン
   type EventError struct {
       Event     Event
       Context   map[string]interface{}
       Cause     error
       Timestamp time.Time
   }
   ```
   - 詳細なエラー情報
   - エラーの追跡可能性
   - コンテキストの保持

2. トランザクション的な処理
   - 変更のアトミック性
   - ロールバックメカニズム
   - 状態の一貫性保証

### 4. パフォーマンス最適化
#### 現状の課題
1. バッチ処理の効率
   ```go
   // 非効率なパターン
   for _, event := range events {
       process(event)  // 個別処理
   }
   ```
   - オーバーヘッドの蓄積
   - リソースの非効率な使用
   - 処理の遅延

2. イベントの優先度
   ```go
   // 単純すぎるパターン
   if update.priority > existing.priority {
       // 優先度だけで判断
   }
   ```
   - コンテキストの無視
   - 静的な優先度のみ
   - 処理順序の最適化不足

#### 改善方針
1. バッチ最適化
   - イベントの集約
   - バッファリング戦略
   - 並列処理の活用

2. スマートな優先度制御
   - 動的優先度の導入
   - コンテキストの考慮
   - 処理順序の最適化

## 初期実装計画

### 1. 移行対象の選定
#### 対象コマンド
1. Ctrl+S (SaveCommand)
   - ファイル保存コマンド
   - バッファ内容に影響なし
   - UI更新は最小限（ステータスメッセージのみ）

2. Ctrl+C/Q (QuitCommand)
   - エディタ終了コマンド
   - 状態変更は最終段階のみ
   - 警告表示のUIイベントフロー検証に適切

### 2. 実装範囲
#### 1. SaveCommand の移行
1. イベント定義
```go
type SaveEvent struct {
    BaseEvent
    Filename string
    Force    bool  // 警告を無視して保存
}
```

2. 処理フロー
```
SaveCommand.Execute
└→ FileEvent発行
   └→ FileEventHandler
      ├→ ファイル保存処理
      ├→ 状態更新イベント発行
      └→ UI更新イベント発行（ステータス）
```

#### 2. QuitCommand の移行
1. イベント定義
```go
type QuitEvent struct {
    BaseEvent
    Force    bool  // 警告を無視して終了
    SaveNeeded bool
}
```

2. 処理フロー
```
QuitCommand.Execute
└→ QuitEvent発行
   └→ SystemEventHandler
      ├→ 状態チェック
      ├→ 警告表示イベント発行（必要時）
      └→ 終了処理実行（Force=true時）
```

### 3. 実装対象ファイル
1. イベント定義
- `editor/events/system_event.go`（新規）
  - QuitEvent
  - SystemEventType
  - SystemEventHandler

2. イベントハンドラ
- `editor/events/manager.go`
  - SystemEventHandlerの登録処理
  - イベントの優先度制御

3. コマンド修正
- `editor/command.go`
  - SaveCommand
  - QuitCommand
  - イベント発行処理の追加

4. エディタ本体
- `editor/editor.go`
  - createControlKeyCommand
  - SystemEventHandlerの実装

### 4. テスト計画
1. ユニットテスト
- `editor/events/system_event_test.go`（新規）
  - イベント生成
  - ハンドラ処理
  - 状態遷移

2. 統合テスト
- `editor/editor_test.go`
  - コマンド→イベント変換
  - イベントチェーン
  - エラー処理

### 5. 検証ポイント
1. イベントフロー
- イベント発行タイミング
- ハンドラの実行順序
- 状態更新の整合性

2. エラー処理
- ファイル保存エラー
- 状態不整合
- リカバリー処理

3. パフォーマンス
- イベント処理のオーバーヘッド
- メモリ使用量
- レイテンシ

## 初期実装の段階的移行手順

### Phase 1: システムイベント基盤の実装
#### 1. システムイベントの定義
1. イベントタイプの追加
```go
const (
    SystemEventType EventType = "system"
)

type SystemEventSubType string
const (
    SystemSave   SystemEventSubType = "save"
    SystemQuit   SystemEventSubType = "quit"
    SystemStatus SystemEventSubType = "status"
)
```

2. イベントインターフェースの拡張
```go
type SystemEvent interface {
    Event
    GetSystemType() SystemEventSubType
}
```

#### 2. イベントハンドラの実装
1. ハンドラインターフェース
```go
type SystemEventHandler interface {
    HandleSaveEvent(event *SaveEvent) error
    HandleQuitEvent(event *QuitEvent) error
    HandleStatusEvent(event *StatusEvent) error
}
```

2. デフォルトハンドラ
```go
type DefaultSystemEventHandler struct {
    editor EditorOperations
}
```

### Phase 2: 既存コマンドの拡張
#### 1. SaveCommandの拡張
1. インターフェースの維持
```go
func (c *SaveCommand) Execute() error {
    // 既存のインターフェースは維持
    return c.executeWithEvents()
}
```

2. イベントベースの実装追加
```go
func (c *SaveCommand) executeWithEvents() error {
    event := NewSaveEvent(c.editor.GetFilename())
    return c.editor.GetEventManager().Publish(event)
}
```

#### 2. QuitCommandの拡張
1. 状態チェックの分離
```go
func (c *QuitCommand) requiresConfirmation() bool {
    return c.editor.IsDirty() && !c.editor.IsQuitWarningShown()
}
```

2. イベントベースの実装
```go
func (c *QuitCommand) executeWithEvents() error {
    event := NewQuitEvent(c.requiresConfirmation())
    return c.editor.GetEventManager().Publish(event)
}
```

### Phase 3: エラー処理とリカバリー
#### 1. エラーコンテキストの強化
1. システムイベントエラー
```go
type SystemEventError struct {
    EventError
    SystemType SystemEventSubType
    Operation  string
}
```

2. リカバリーハンドラ
```go
func (h *DefaultSystemEventHandler) Recover(err error) error {
    // エラー状態からの復帰処理
    return h.editor.GetEventManager().Publish(NewStatusEvent(err.Error()))
}
```

#### 2. ロールバック機構
1. 状態スナップショット
```go
type SystemStateSnapshot struct {
    Timestamp  time.Time
    EventType  SystemEventSubType
    State      map[string]interface{}
}
```

2. 状態復元
```go
func (h *DefaultSystemEventHandler) RestoreState(snapshot *SystemStateSnapshot) error {
    // 状態の復元処理
    return nil
}
```

### Phase 4: イベント最適化
#### 1. バッチ処理の導入
1. イベントのグループ化
```go
type SystemEventBatch struct {
    Events []SystemEvent
    Priority int
}
```

2. バッチハンドラ
```go
func (h *DefaultSystemEventHandler) HandleBatch(batch *SystemEventBatch) error {
    // バッチ処理の最適化
    return nil
}
```

#### 2. パフォーマンス制御
1. イベントスロットリング
```go
type SystemEventThrottler struct {
    MaxEventsPerSecond int
    EventQueue *queue.PriorityQueue
}
```

2. メトリクス収集
```go
type SystemEventMetrics struct {
    ProcessingTime time.Duration
    QueueLength   int
    ErrorCount    int
}
```

### Phase 5: 移行の完了
#### 1. 既存コードの置き換え
1. コマンドファクトリの更新
```go
func (e *Editor) createSystemCommand(eventType SystemEventSubType) Command {
    return NewEventBasedCommand(e, eventType)
}
```

2. 直接呼び出しの除去
```go
// 削除対象
editor.SaveFile()
// 新実装
editor.GetEventManager().Publish(NewSaveEvent(filename))
```

#### 2. テスト環境の整備
1. イベントモック
```go
type MockSystemEventHandler struct {
    HandleSaveFunc func(*SaveEvent) error
    HandleQuitFunc func(*QuitEvent) error
}
```

2. 統合テストの拡充
```go
func TestSystemEventFlow(t *testing.T) {
    // イベントフローの検証
}
```

### 実装の優先順位
1. 第1週目
- システムイベントの基本実装
- SaveEventの実装と移行
- 基本的なエラー処理

2. 第2週目
- QuitEventの実装と移行
- エラーリカバリー機構
- 初期テストケース

3. 第3週目
- パフォーマンス最適化
- テストの拡充
- ドキュメント整備